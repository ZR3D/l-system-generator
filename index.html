<!DOCTYPE html>
<html lang="en">
<head>
<title>L-System Fractal Generator</title>
<meta content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" name="viewport">
<style>
body{font-family:sans-serif; font-size: 13px; padding:0px; margin:0px; background-color:#7f9fbd;}
button{font-family:sans-serif; font-size: 13px;}
#main{
margin-top: 36px;
}
#topPanel {
    position: fixed;
    left: 0;
    top: 0;
    width: 100%;
    background-color: #4b5c6e;
    z-index: 10;
    color: #f1f1f1;
    padding-top: 5px;
}
#topPanel div {
    float: left;
}
.number-text{background-color: #f1f1f1; padding:5px 7px 5px 7px; color: #000;}
button{
    background-color: #2a577c;
    border:none;
    color:white;
    text-decoration:none;
    display:inline-block;
    cursor:pointer;
    border-radius: 3px;
    height: 25px;
    overflow: hidden;
    margin-bottom: 5px;
    vertical-align: middle;
    float: left;
    margin-right: 4px;
    font-family: Sans-Serif;
}
.minus-btn{border-radius:3px 0px 0px 3px; margin: 0px}
.plus-btn{border-radius:0px 3px 3px 0px;}
label{
    display: inline-block;
    float: left;
    padding-top: 4px;
}
select{
    padding-top: 4px;
    display: inline-block;
    float: left;
}

@media print {
    #topPanel{
        display: none !important;
    }
}

input[type="range"] {accent-color:#42769f; float:left;}

</style>
</head>

<body>
    <div id="topPanel">
    <label style="margin-left:10px" for="iterationsText">iterations</label>      
    <button class="minus-btn blue" onclick="changeIterations(-1, true)">-</button>
    <div class="number-text" id="iterationsText">0</div>
    <button class="plus-btn blue" onclick="changeIterations(1, true)">+</button>

    <label style="margin-left:10px" for="lineLengthText">line length</label>      
    <button class="minus-btn blue" onclick="changeLineLength(-1, true)">-</button>
    <div class="number-text" id="lineLengthText">0</div>
    <button class="plus-btn blue" onclick="changeLineLength(1, true)">+</button>

    <label style="margin-left:10px" for="turnAngleText">turn angle</label>      
    <button class="minus-btn blue" onclick="changeTurnAngle(-1, true)">-</button>
    <div class="number-text" id="turnAngleText">0</div>
    <button class="plus-btn blue" onclick="changeTurnAngle(1, true)">+</button>

    <label style="margin-left:10px" for="lsysMenu">L System</label>  
    <select id="lsysMenu" onchange="changeFromMenu(true)"></select>

    <button style="margin-left:10px;" onclick="saveSvg()">Save SVG</button>
    <button style="margin-left:10px;" onclick="savePng()">Save PNG</button>
    
    <input id="colourPicker1" type="color" value="#000000" />
    <input id="colourPicker2" type="color" value="#ffffff" />
    
    <button onclick="copySvgToClipboard(layer1)">copy to clipboard</button>
    
    <div class="label">zoom</div>  
    <input id="zoomRange" type="range" min="10" max="200" value="100" class="range" oninput="changeZoomRange(this.value)" />
    <div id="zoomText" class="range-label">100%</div>
    
    <div class="label">outline inside</div>  
    <input id="outlineInsideRange" type="range" min="0" max="10" value="2" class="range" oninput="changeOutlineInside(this.value)" />
    <div id="outlineInsideText" class="range-label">2</div>   
    
    <div class="label">outline</div>  
    <input id="outlineRange" type="range" min="0" max="10" value="2" class="range" oninput="changeOutline(this.value)" />
    <div id="outlineText" class="range-label">2</div> 

</div>
<div id="main">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1080 1080" id="designSvg" height="1080" width="1080">
        <g id="layer0"><rect id="background" width="1080" height="1080" fill="#ffffff" /></g>
        <g id="layer1"></g>
        <g id="layer2"></g>    
    </svg>
    <style>svg { background-color: rgba(255, 255, 255, 1); }</style>
    <div id="output"></div>
    <div><canvas id="svgCanvas"></canvas></div>
</div>
</body>

<script>
const svgns = "http://www.w3.org/2000/svg";
const container = document.getElementById('designSvg');
const layer1 = document.getElementById('layer1');
const lSystemList = [];
const lsysMenu = document.getElementById('lsysMenu');
const colourPicker1 = document.getElementById('colourPicker1');
const colourPicker2 = document.getElementById('colourPicker2');


function changeOutlineInside(){
    changeFromMenu(true)
}

function changeOutline(){
    changeFromMenu(true)
}

function changeZoomRange(zoom){

    zoomText.innerHTML = zoom;

    const newSize = Math.floor((100/zoom)*1080);   
    container.setAttribute("viewBox", "0 0 " + newSize + " " + newSize);
    updateCrop();
    saveLocalStorage();
}



function rotateAroundPoint(centerOfRotation, degrees, length){
	var xRot = centerOfRotation.x + (Math.cos(Math.PI/180 * degrees)*length);
	var yRot = centerOfRotation.y + (Math.sin(Math.PI/180 * degrees)*length);
	return {x:xRot,y:yRot};
}

function createCircle(id, pos, r, stroke, fill, strokeWidth){
		var circle = document.createElementNS(svgns, 'circle');
		circle.setAttributeNS(null, 'id', id);
		circle.setAttributeNS(null, 'cx', pos.x);
        circle.setAttributeNS(null, 'cy', pos.y);
        circle.setAttributeNS(null, 'r', r);
		circle.setAttributeNS(null, 'style', 'fill:' + fill + '; stroke:' + stroke + ';  opacity:1; stroke-width:' + strokeWidth + ';' );
		layer1.appendChild(circle);
}
     

function createPath(posList, fill, stroke, strokeWidth, adjx, adjy){
	    var path = document.createElementNS(svgns, 'path');
		var d = "M" + (posList[0].x + adjx) + " " + (posList[0].y + adjy);
		//d += "A 1300 1300 0 0 1 "+ posList[1].x + " " + posList[1].y;
       
		for(var i=1; i<posList.length; i++) {
            var pos = posList[i]
            var com = (pos.command=="M")? " M":" L";
			d += com + (pos.x + adjx) + " " + (pos.y + adjy);
		}
        path.setAttributeNS(null, 'd', d);
		path.setAttributeNS(null, 'style', 'fill:' + fill + '; stroke:' + stroke + ';  opacity:1; stroke-width:' + strokeWidth + ';');
        layer1.appendChild(path);
}


//F	         Move forward by line length drawing a line
//+	         Turn left by turning angle
//-	         Turn right by turning angle
var center = {x:540, y:540};
var lineLength = 10;
var currentPosition = center;
var nextPosition = center;
var posList = [currentPosition];
var convertList = ["X", "Y"];
var iterations = 3;
var turnAngle = 90;
var scaleFactor = 0.6;
var lSys = {};
var branchAngle = 90;
var branchColours = ["#000", "#ff0000", "#00ff00", "#0000ff", "#34aa12", "#123456", "#345612","#000", "#ff0000", "#00ff00", "#0000ff", "#34aa12", "#123456", "#345612"];

function lSystem(title, axiomStr, axiomLetters, ruleSets, turningAngle, convertList, startAngle, branching){
    this.title = title;
    this.axiomStr = axiomStr;  
    this.axiomLetters = axiomLetters;
    this.ruleSets = ruleSets;
    this.turningAngle = turningAngle;
    this.convertList = convertList;
    this.startAngle = startAngle;
    this.branching = branching;
}

function changelSystem(title){
    if(title != lSys.title){ //change only if system is different
        console.log("change: ", title, lSys.title)
        iterations = 3;    
        changeIterations(0, false)        
        var index = lSystemList.findIndex(x => x.title === title);
        lSys = lSystemList[index];
        turnAngle = lSys.turningAngle;
        changeTurnAngle(0, false);
    }
}

//Square Sierpinski
//Written by Paul Bourke
//August 1990
//First reported circa 1912
//axiom = F+XF+F+XF
//X -> XF-F+F-XF+F+XF-F+F-X
var title = "Square Sierpinski"
var axiomStr = "F+XF+F+XF"
var ruleSets = ["XF-F+F-XF+F+XF-F+F-X"];
var axiomLetters = ["X"];
var turningAngle = 90;
var convertList = ["X"];
var startAngle = 0;
var branching = false;
lSystemList.push(new lSystem(title, axiomStr, axiomLetters, ruleSets, turningAngle, convertList, startAngle, branching));

var title = "Kosh Showflake";
var axiomStr = "F ++F ++F";
var axiomLetters = ["F"];
var ruleSets = ["F -F ++F -F"];
var turningAngle = 60;
var convertList = [];
var startAngle = 0;
var branching = false;
lSystemList.push(new lSystem(title, axiomStr, axiomLetters, ruleSets, turningAngle, convertList, startAngle, branching));

//Hilbert
//Written by Paul Bourke
//June 1990
//Attributed to the German mathematician David Hilbert, circa 1891
//axiom = X
//X -> -YF+XFX+FY-
//Y -> +XF-YFY-FX+
var title = "Hilbert Curve";
var axiomStr = "X";
var ruleSets = ["-YF+XFX+FY-", "+XF-YFY-FX+"];
var axiomLetters = ["X","Y"];
var turningAngle = 90;
var convertList = [];
var startAngle = 0;
var branching = false;
lSystemList.push(new lSystem(title, axiomStr, axiomLetters, ruleSets, turningAngle, convertList, startAngle, branching));


//Crystal
//Written by Paul Bourke
//June 1990
//axiom = F+F+F+F
//F -> FF+F++F+F
var title = "Crystal";
var turningAngle = 90;
var axiomStr = "F +F +F +F";
var ruleSets = ["F F +F ++F +F"];
var axiomLetters = ["F"];
var convertList = [];
var startAngle = 0;
var branching = false;
lSystemList.push(new lSystem(title, axiomStr, axiomLetters, ruleSets, turningAngle, convertList, startAngle, branching));

//Sierpinski Arrowhead
//Written by Paul Bourke
//June 1990
var title = "Sierpinski Arrowhead"
var axiomStr = "YF";
var ruleSets = ["YF+XF+Y","XF-YF-X"]
var axiomLetters = ["X","Y"];
var turningAngle = 60;
var convertList = ["X","Y"];
var startAngle = 0;
var branching = false;
lSystemList.push(new lSystem(title, axiomStr, axiomLetters, ruleSets, turningAngle, convertList, startAngle, branching));

var title = "Sierpinski Arrowhead 2"
var axiomStr = "A";
var ruleSets = ["B-A-B","A+B+A"]
var axiomLetters = ["A","B"];
var turningAngle = 60;
var convertList = ["A","B"];
var startAngle = 0;
var branching = false;
lSystemList.push(new lSystem(title, axiomStr, axiomLetters, ruleSets, turningAngle, convertList, startAngle, branching));


var title = "Sierpinski Triangle"
var axiomStr = "F-G-G";
var ruleSets = ["F-G+F+G-F","GG"]
var axiomLetters = ["F","G"];
var turningAngle = 120;
var convertList = ["F","G"];
var startAngle = 0;
var branching = false;
lSystemList.push(new lSystem(title, axiomStr, axiomLetters, ruleSets, turningAngle, convertList, startAngle, branching));


var title = "Koch curve"
//A variant of the Koch curve which uses only right angles.
//variables : F
//constants : + −
//start  : F
//rules  : (F → F+F−F−F+F)
var axiomStr = "F";
var ruleSets = ["F+F-F-F+F"];
var axiomLetters = ["F"];
var turningAngle = 90;
var convertList = [];
var startAngle = 0;
var branching = false;
lSystemList.push(new lSystem(title, axiomStr, axiomLetters, ruleSets, turningAngle, convertList, startAngle, branching));

var title = "Quadratic Snowflake"
//A variant of the Koch curve which uses only right angles.
//variables : F
//constants : + −
//start  : F
//rules  : (F → F+F−F−F+F)
var axiomStr = "F";
var ruleSets = ["F-F+F+F-F"];
var axiomLetters = ["F"];
var turningAngle = 90;
var convertList = [];
var startAngle = 0;
var branching = false;
lSystemList.push(new lSystem(title, axiomStr, axiomLetters, ruleSets, turningAngle, convertList, startAngle, branching));


//Quadratic Snowflake
//Written by Paul Bourke
//July 1990
//axiom = F
//F -> F-F+F+F-F
//angle = 90
var title = "Rings";
var axiomStr = "F +F +F +F";
var ruleSets = ["F F +F +F +F +F +F -F"];
var axiomLetters = ["F"];
var turningAngle = 90
var convertList = [];
var startAngle = 45;
var branching = false;
lSystemList.push(new lSystem(title, axiomStr, axiomLetters, ruleSets, turningAngle, convertList, startAngle, branching));

//axiom = FX
//X -> X+YF+
//Y -> -FX-Y
var title = "Dragons curve";
var axiomStr = "FX";
var ruleSets = ["X+YF+"," -FX-Y"]
var axiomLetters = ["X","Y"];
var turningAngle = 90;
var convertList = [];
var startAngle = 0;
var branching = false;
lSystemList.push(new lSystem(title, axiomStr, axiomLetters, ruleSets, turningAngle, convertList, startAngle, branching));


//Quadratic Gosper
//Written by Paul Bourke
//June 1990
//Attributed to Dekking, 1982
//axiom = -YF
//X -> XFX-YF-YF+FX+FX-YF-YFFX+YF+FXFXYF-FX+YF+FXFX+YF-FXYF-YF-FX+FX+YFYF-
//Y -> +FXFX-YF-YF+FX+FXYF+FX-YFYF-FX-YF+FXYFYF-FX-YFFX+FX+YF-YF-FX+FX+YFY
//angle = 90
var title = "Quadratic Gosper";
var axiomStr = "-YF";
var ruleSets = [
"XFX-YF-YF+FX+FX-YF-YFFX+YF+FXFXYF-FX+YF+FXFX+YF-FXYF-YF-FX+FX+YFYF-",
"+FXFX-YF-YF+FX+FXYF+FX-YFYF-FX-YF+FXYFYF-FX-YFFX+FX+YF-YF-FX+FX+YFY"]
var axiomLetters = ["X","Y"];
var turningAngle = 90;
var convertList = [];
var startAngle = 0;
var branching = false;
lSystemList.push(new lSystem(title, axiomStr, axiomLetters, ruleSets, turningAngle, convertList, startAngle, branching));


//Quadratic Koch Island
//Written by Paul Bourke
//July 1990
/*
axiom = F+F+F+F
F -> F+F-F-FFF+F+F-F
angle = 90
String length: 63
*/
var title = "Quadratic Koch Island";
var axiomStr = "F+F+F+F";
var ruleSets = ["F+F-F-FFF+F+F-F"];
//var ruleSets = ["F +F -F -F F +F +F -F"]; //- first one
var axiomLetters = ["F"];
var turningAngle = 90;
var convertList = [];
var startAngle = 0;
var branching = false;
lSystemList.push(new lSystem(title, axiomStr, axiomLetters, ruleSets, turningAngle, convertList, startAngle, branching));

/*
axiom = F+F+F+F
F -> F-FF+FF+F+F-F-FF+F+F-F-FF-FF+F
angle = 90
*/
var title = "Quadratic Koch Island 2";
var axiomStr = "F+F+F+F";
var ruleSets = ["F-FF+FF+F+F-F-FF+F+F-F-FF-FF+F"];
lSystemList.push(new lSystem(title, axiomStr, axiomLetters, ruleSets, turningAngle, convertList, startAngle, branching));
/*
Variation by Hasan Hosam.
December 2018
axiom = X+X+X+X+X+X+X+X
X -> X+YF++YF-FX--FXFX-YF+X
Y -> -FX+YFYF++YF+FX--FX-YF
angle = 45
*/

var title = "Quadratic Koch Island Hosam";
var axiomStr = "X+X+X+X+X+X+X+X";
var ruleSets = ["X+YF++YF-FX--FXFX-YF+X","-FX+YFYF++YF+FX--FX-YF"];
//var convertList = ["X","Y"]
var axiomLetters = ["X","Y"];
var turningAngle = 45;
lSystemList.push(new lSystem(title, axiomStr, axiomLetters, ruleSets, turningAngle, convertList, startAngle, branching));


//Peano Curve
//Written by Paul Bourke
//June 1990
//First documented circa 1890

var title = "Peano Curve";
var axiomStr = "X";
var ruleSets = ["XFYFX+F+YFXFY-F-XFYFX", "YFXFY-F-XFYFX+F+YFXFY"];
var axiomLetters = ["X","Y"];
var turningAngle = 90;
//var convertList = ["X","Y"];
var startAngle = 90;
var branching = false;
lSystemList.push(new lSystem(title, axiomStr, axiomLetters, ruleSets, turningAngle, convertList, startAngle, branching));

//Pentaplexity
//Written by Paul Bourke
//September 1990
//axiom = F++F++F++F++F
//F -> F++F++F|F-F++F
//angle = 36
var title = "Pentaplexity";
var axiomStr = "F++F++F++F++F";
var ruleSets = ["F++F++F|F-F++F"];
var axiomLetters = ["F"];
var turningAngle = 36;
var startAngle = 0;
lSystemList.push(new lSystem(title, axiomStr, axiomLetters, ruleSets, turningAngle, convertList, startAngle, branching));

//Hexagonal Gosper
//Written by Paul Bourke
//July 1990
//Attributed to Mandelbrot, 1982
//axiom = XF
//X -> X+YF++YF-FX--FXFX-YF+
//Y -> -FX+YFYF++YF+FX--FX-Y
//angle = 60
var title = "Hexagonal Gosper";
var axiomStr = "XF";
var ruleSets = ["X+YF++YF-FX--FXFX-YF+","-FX+YFYF++YF+FX--FX-Y"];
var axiomLetters = ["X","Y"];
var turningAngle = 60;
var startAngle = 0;
lSystemList.push(new lSystem(title, axiomStr, axiomLetters, ruleSets, turningAngle, convertList, startAngle, branching));

//Lévy curve
//Written by Paul Bourke
//February 2019
//axiom = F
//F -> -F++F-
//angle = 45
var title = "Levy curve";
var axiomStr = "F";
var ruleSets = ["-F++F-"];
var axiomLetters = ["F"];
var turningAngle = 45;
var startAngle = 0;
lSystemList.push(new lSystem(title, axiomStr, axiomLetters, ruleSets, turningAngle, convertList, startAngle, branching));


//Kolam
//January 2019
//axiom = (-D--D)
//A -> F++FFFF--F--FFFF++F++FFFF--F
//B -> F--FFFF++F++FFFF--F--FFFF++F
//C -> BFA--BFA
//D -> CFC--CFC
//angle = 45
var title = "Kolam";
var axiomStr = "-D--D";
var ruleSets = ["F++FFFF--F--FFFF++F++FFFF--F","F--FFFF++F++FFFF--F--FFFF++F","BFA--BFA","CFC--CFC"];
var axiomLetters = ["A","B","C","D"];
var convertList = [];
//var convertList = ["A","B","C","D"];
var turningAngle = 45;
var startAngle = 0;
lSystemList.push(new lSystem(title, axiomStr, axiomLetters, ruleSets, turningAngle, convertList, startAngle, branching));

/*

Snake Kolam
Written by Paul Bourke
axiom = F+XF+F+XF
X -> X{F-F-F}+XF+F+X{F-F-F}+X
angle = 90
{}== open/close polygon
*/

var title = "Snake Kolam";
var axiomStr = "F+XF+F+XF";
var ruleSets = ["X{F-F-F}+XF+F+X{F-F-F}+X"];
var axiomLetters = ["X"];
var convertList = [];
var turningAngle = 90;
lSystemList.push(new lSystem(title, axiomStr, axiomLetters, ruleSets, turningAngle, convertList, startAngle, branching));



/*
Mango Leaf
Written by Paul Bourke
axiom = Y---Y
X -> {F-F}{F-F}--[--X]{F-F}{F-F}--{F-F}{F-F}--
Y -> f-F+X+F-fY
angle = 60
f	         Move forward by line length without drawing a line
*/
var title = "Mango Leaf";
var axiomStr = "Y---Y";
var ruleSets = ["{F-F}{F-F}--[--X]{F-F}{F-F}--{F-F}{F-F}--","f-F+X+F-fY"];
var axiomLetters = ["X","Y"];
var convertList = [];
var turningAngle = 60;
lSystemList.push(new lSystem(title, axiomStr, axiomLetters, ruleSets, turningAngle, convertList, startAngle, branching));





//Classic Sierpinski Curve
//Written by Paul Bourke
//Rules by Chris Wallace
//November 2019
var title = "Classic Sierpinski Curve";
var axiomStr = "F--XF--F--XF";
var ruleSets = ["XF+F+XF--F--XF+F+X"]
var axiomLetters = ["X"];
var convertList = ["F","X"];
var turningAngle = 45;
var startAngle = 0; //45
lSystemList.push(new lSystem(title, axiomStr, axiomLetters, ruleSets, turningAngle, convertList, startAngle, branching));

//Angle 90
//Axiom F
//F —> F+F−F−F−G+F+F+F−F
//G —> GGG
var title = "Sierpinski Carpet";
var axiomStr = "F";
//var ruleSets = ["F+F-F-F-G+F+F+F-F", "GGG"];
var ruleSets = ["F+F-F-F-UGD+F+F+F-F", "GGG"]; //Don't draw through lines
var axiomLetters = ["F","G"];
var convertList = ["G"];
var turningAngle = 90;
var startAngle = 45; 
var branching = false;
lSystemList.push(new lSystem(title, axiomStr, axiomLetters, ruleSets, turningAngle, convertList, startAngle, branching));

var title = "Test";
var axiomStr = "F";
//var ruleSets = ["F+F-F-F-G+F+F+F-F", "GGG"];
var ruleSets = ["+FUGDF", "+FUGD"]; //Don't draw through lines
var axiomLetters = ["F","G"];
var convertList = ["G"];
var turningAngle = 0;
var startAngle = 0; 
var branching = false;
lSystemList.push(new lSystem(title, axiomStr, axiomLetters, ruleSets, turningAngle, convertList, startAngle, branching));


//Cross
//Written by Paul Bourke
//August 1990
//axiom = F+F+F+F
//F -> F+F-F+F+F
//angle = 90
var title = "Cross";
var axiomStr = "F+F+F+F";
var ruleSets = ["F+F-F+F+F"];
var axiomLetters = ["F"];
var convertList = [];
var startAngle = 0;
var turningAngle = 90;
lSystemList.push(new lSystem(title, axiomStr, axiomLetters, ruleSets, turningAngle, convertList, startAngle, branching));



var title = "Cross 2";
var axiomStr = "F+F+F+F";
var ruleSets = ["F+FF++F+F"];
lSystemList.push(new lSystem(title, axiomStr, axiomLetters, ruleSets, turningAngle, convertList, startAngle, branching));






//Triangle
//Written by Paul Bourke
//July 1990
var title = "Triangle";
var axiomStr = "F+F+F";
var ruleSets = ["F-F+F"];
var axiomLetters = ["F"];
var convertList = [];
var startAngle = -90;
var turningAngle = 120;
lSystemList.push(new lSystem(title, axiomStr, axiomLetters, ruleSets, turningAngle, convertList, startAngle, branching));

var title = "Tree";
var axiomStr = "F";
var ruleSets = ["F[+F][-F]"];
var axiomLetters = ["F"];
//var turningAngle = 60;
var turningAngle = 60;
var convertList = [];
var startAngle = -90;
var branching = true;
lSystemList.push(new lSystem(title, axiomStr, axiomLetters, ruleSets, turningAngle, convertList, startAngle, branching));

var title = "Tree 2";
var ruleSets = ["F[+F]F[+F][-F]"];
lSystemList.push(new lSystem(title, axiomStr, axiomLetters, ruleSets, turningAngle, convertList, startAngle, branching));

var title = "Tree 3";
var ruleSets = ["F[+F][-F]F[+F][-F]"];
lSystemList.push(new lSystem(title, axiomStr, axiomLetters, ruleSets, turningAngle, convertList, startAngle, branching));

//axiom = FX
//X -> >[-FX]+FX
//angle = 40

var title = "Tree 4"
var axiomStr = "FX";
var ruleSets = ["[-FX]+FX"];
var axiomLetters = ["X"];
var convertList = [];
var turningAngle = 40;
lSystemList.push(new lSystem(title, axiomStr, axiomLetters, ruleSets, turningAngle, convertList, startAngle, branching));

/*
L-System Leaf
Written by Paul Bourke
axiom = a
F -> >F<
a -> F[+x]Fb
b -> F[-y]Fa
x -> a
y -> b
angle = 45
length factor = 1.36
*/

function populateLSysMenu(){    
    for(var i=0; i<lSystemList.length; i++){
        lsysMenu.innerHTML += '<option value="' + lSystemList[i].title + '">' + lSystemList[i].title + '</otion>';
    }
}

function changeFromMenu(update){
    if(update){
        layer1.innerHTML = "";
        currentPosition = {x:540, y:540};
        nextPosition = currentPosition;
        posList = [currentPosition];    
        changelSystem(lsysMenu.value);
        create();
    }
}


function iterate(axiomStr, axiomLetters, ruleSetsruleSets){
    var iterationStr = axiomStr;
    for(var i=0; i<lSys.axiomLetters.length; i++){
        var ruleSet = lSys.ruleSets[i].toLowerCase();
        iterationStr = replaceGlobally(iterationStr, axiomLetters[i], ruleSet);
    }
    iterationStr = iterationStr.replace(/ +(?= )/g,'');
    
    return iterationStr.toUpperCase().trim();
}

function replaceGlobally(original, searchTxt, replaceTxt){
    const regex = new RegExp(searchTxt, 'g');
    return original.replace(regex, replaceTxt) ;
}

function getIterationList(){
    var iterationString = lSys.axiomStr;
    for(var i=0; i<iterations; i++){
        iterationString = iterate(iterationString,lSys.axiomLetters, lSys.ruleSets);
    }
    iterationString = iterationString.replace(/\s/g, ""); //remove whitespace
    //console.log(iterationString, iterationString.split(""));   
    return iterationString.split("");
}

function getAngle(str, angle){
    if(str=="F"){
        angle = angle;        
    }else if(str=="-"){
        angle = angle + turnAngle; 
    }else if(str=="+"){
        angle = angle - turnAngle;         
    }else if(str=="|"){
        angle = angle + (turnAngle*5); 
    }
    return angle;
}

const app = new function () {
    this.penDown = true;
    this.branchList = [];
    this.branchIndex = 0;
    this.recursiveBranchDepthIndex = 0;
}



function Branch(pos, angle){
    this.pos = pos;
    this.angle = angle;
    this.updatePos = function(pos){
        this.pos = pos;
    }
    this.updateAngle = function(angle){
        this.angle = angle;
    }
}


//var branchLength = [];



/*
function populateBranchLength(depth){
    var bl = 1;
    var scaleFactor = 0.6;
    branchLength = [];
    for(var i=0; i<depth; i++){     
        branchLength.push(bl-(i*scaleFactor))
        console.log(branchLength)
    }
}
*/
//0.66;
//var scaleFactor = 0.57; //self avoiding
//var scaleFactor = 0.61803; //self contacting
var scaleFactor =  0.65 //Self-overlapping
/*
function getBranchLength(index){
    var lineL = lineLength;
    branchLength = [];
    for(var i=0; i<index; i++){ 
        //lineL = lineL * scaleFactor;
        lineL = lineLength * Math.pow(scaleFactor, i)    
        
        branchLength.push(lineL)
    }  
    //console.log(branchLength)    
}

getBranchLength(8);
*/

/*
var branchLength = [];



function setBranchLength(depth){
    if(branchLength.length<depth){
        populateBranchLength(depth)
    }
}
*/


//populateBranchLength(5);

var startAngle = 0;

function getPosition(str){
    currentPosition = nextPosition;
    //convert X,Y to F
    for(var i=0; i<lSys.convertList.length; i++){ 
        str = str.replace(lSys.convertList[i], "F");
    }   
    if(str.includes("[")){
        app.branchList[app.branchIndex] = new Branch(currentPosition, startAngle);
        //console.log("set: ", lSys.startAngle, currentPosition);
        app.branchIndex++;
        app.branchList[app.branchIndex] = new Branch(currentPosition, startAngle); 
        startAngle = app.branchList[app.branchIndex].angle;
        currentPosition = app.branchList[app.branchIndex].pos;        
    }else if (str.includes("]")){ 
        //reset to previous index settings
        app.branchIndex--;
        startAngle = app.branchList[app.branchIndex].angle;
        currentPosition = app.branchList[app.branchIndex].pos;
        nextPosition = currentPosition; 
        //console.log("reset: ", lSys.startAngle, currentPosition);
    }else{            
    startAngle = getAngle(str, startAngle);    
    //console.log(str, app.branchIndex, app.branchList[app.branchIndex]);
        if(str.includes("F")){
            lineLen = (lSys.branching)? ((lineLength * Math.pow(scaleFactor, app.branchIndex))*20):lineLength
            //lineLen = (lSys.branching)? (lineLength * branchLength[app.branchIndex]):lineLength
            nextPosition = rotateAroundPoint(currentPosition, startAngle, lineLen);
            nextPosition.command = "S";
            if(lSys.branching){
                createPath([currentPosition,nextPosition], "rgba(0,0,0,0.05)", branchColours[app.branchIndex], 1, 0, 0);
            }        
        }else{
            nextPosition = currentPosition;
            nextPosition.command = "S";
            if(str.includes("U")){
                app.penDown = false;
            }else if(str.includes("D")){
                app.penDown = true;
                nextPosition.command = "M";                                
            }
            //console.log(nextPosition) 
        } 
    }
    
    //console.log(str, app.penDown, nextPosition.command)
}
var designMin = {};
var designMax = {};

function resetMinMax(){
    designMin = {x:1000, y:1000}
    designMax = {x:0, y:0}
}

function minMaxer(pos){
    if(pos.x<designMin.x){designMin.x = pos.x;}
    if(pos.y<designMin.y){designMin.y= pos.y;}
    if(pos.x>designMax.x){designMax.x = pos.x;}
    if(pos.y>designMax.y){designMax.y = pos.y;}
}

function transformPoint(pos){
    var pt = designSvg.createSVGPoint();
    pt.x = pos.x;
    pt.y = pos.y;
    return pt.matrixTransform(designSvg.getScreenCTM().inverse());
}

function drawFromList(iterationList){
    resetMinMax();
    startAngle = lSys.startAngle;
    //console.log(currentPosition, lSys.startAngle);
    app.branchList[0] = new Branch(currentPosition, lSys.startAngle);
    for(var i=0; i<iterationList.length; i++){
        var ruleLetter = iterationList[i];
        getPosition(ruleLetter);
        //console.log(nextPosition)
        if((currentPosition != nextPosition) || (nextPosition.command == "M" & app.penDown)){ // & app.penDown
            minMaxer(nextPosition)
            //console.log(nextPosition, app.penDown)
            posList.push(nextPosition);
        }
        
    }
    //console.log(designMin,designMax, (designMax.x - designMin.x), (designMax.y - designMin.y))
    //createPath([designMin,designMax], "#ff0000", "#ff0000", 1, 0, 0);    
    //designMinTransformed = transformPoint(designMin);
    //designMaxTransformed = transformPoint(designMax);
    //console.log(designMinTransformed,designMaxTransformed, (designMaxTransformed.x - designMinTransformed.x), (designMaxTransformed.y - designMinTransformed.y))
    var adjustx =  designMin.x + ((designMax.x - designMin.x) * 0.5);
    var adjusty =  designMin.y + ((designMax.y - designMin.y) * 0.5);
    var adjx = center.x - adjustx;
    var adjy = center.y - adjusty;
    
    

    outline = outlinePoints(posList, true, outlineInsideRange.value, true)
    createPath(outline, "rgba(0,0,0,0.1)", "#222", 1, adjx, adjy)
    
    //console.log(adjx, adjy)         
    //createCircle("x", {x:adjustx, y:adjusty}, 4, "#00ff00", "#00ff00", 0)    
    if(!lSys.branching){
        var col1 = colourPicker1.value
        var col2 = colourPicker2.value
        document.getElementById("background").setAttribute("fill", col2);
        var print = false;
        if(print){
            createPath(posList, "rgba(0,0,0,0.0)", "#000", 4, adjx, adjy);
            createPath(posList, "rgba(0,0,0,0.0)", "#fff", 3, adjx, adjy);
        }else{
            createPath(posList, "rgba(0,0,0,0.1)", "#222", 1, adjx, adjy); 
        }
    }    
    //createCircle("x", {x:600, y:600}, 4, "#00ff00", "#00ff00", 0)
    

    outline = outlinePoints(posList, false, outlineRange.value, true)
    createPath(outline, "rgba(0,0,0,0.1)", "#222", 1, adjx, adjy);

    
    
}

function create(){
    var iterationList = getIterationList();
    //console.log(app.branchList.length, branchLength.length)    
    //setBranchLength(app.branchList.length+1)    
    drawFromList(iterationList);
    
    
}

function clamp(min, max, val, original){
    if((val+original<min) || (val+original>max)){
        val=0;
    }
    return val;
}

function changeIterations(val, update){
    val = clamp(0, 20, val ,iterations);
    iterations += val;
    document.getElementById("iterationsText").innerHTML = iterations;
    changeFromMenu(update); 
}

function changeLineLength(val, update){
    val = clamp(1, 50, val ,lineLength);
    lineLength += val;    
    document.getElementById("lineLengthText").innerHTML = lineLength;
    changeFromMenu(update); 
}


function changeTurnAngle(val, update){
    val = clamp(0, 360, val ,turnAngle);
    turnAngle += val;
    document.getElementById("turnAngleText").innerHTML = turnAngle;
    changeFromMenu(update); 
}


function getIndex(num, total){
    let index = num % total
    if(index<0){
       index = total + num;
    }
    return index;
}

function lineAngle(pos1, pos2, positiveOnly){
	var deltaX = pos2.x - pos1.x ;
	var deltaY = pos2.y - pos1.y;
	var rad = Math.atan2(deltaY, deltaX); // In radians
	var deg = rad * (180 / Math.PI); // In degrees
	if(positiveOnly){
        if(deg<0){
            deg+=360}
        ;
    } 
    return Number(deg.toFixed(5));
}

//improved line intersect - includes is the intersection along the segments
function lineIntersect(pos1, pos2, pos3, pos4, alongSegment){
  // Check if none of the lines are of length 0
	if ((pos1.x === pos2.x && pos1.y === pos2.y) || (pos3.x === pos4.x && pos3.y === pos4.y)) {
		return false;
	}
	var denominator = ((pos4.y - pos3.y) * (pos2.x - pos1.x) - (pos4.x - pos3.x) * (pos2.y - pos1.y));
  // Lines are parallel
	if (denominator === 0) {
		return false;
	}
	let ua = ((pos4.x - pos3.x) * (pos1.y - pos3.y) - (pos4.y - pos3.y) * (pos1.x - pos3.x)) / denominator;
	let ub = ((pos2.x - pos1.x) * (pos1.y - pos3.y) - (pos2.y - pos1.y) * (pos1.x - pos3.x)) / denominator;
  
    //is the intersection along the segments
    if(alongSegment==true){
        //console.log("in:", alongSegment)
        if (ua < 0 || ua > 1 || ub < 0 || ub > 1) {
            return false;
        }
    }
  // Return a object with the x and y coordinates of the intersection
	let x = pos1.x + ua * (pos2.x - pos1.x);
	let y = pos1.y + ua * (pos2.y - pos1.y);
	return {x, y};
}

function outlinePoints(pointListSrc, outside, width, closed){
    //console.log(pointListSrc)
    const pointList = Object.create(pointListSrc);
    //remove last as the same as first
    if(closed) pointList.pop(); 

    //console.log(closed)
    const angleAddition = (outside)? 90:-90;
    const loopAddition = (closed)? 1:-1;
    const pointListNew = [];
    const pointListLen = pointList.length;
    
    for(var i=0; i<(pointListLen+loopAddition); i++){
    //for(var i=0; i<pointListLen; i++){
        var firstPoint = pointList[getIndex(i, pointListLen)];
        var secondPoint = pointList[getIndex(i+1, pointListLen)];
        var thirdPoint = pointList[getIndex(i+1, pointListLen)];
        var fourthPoint = pointList[getIndex(i+2, pointListLen)];
        
        //console.log(firstPoint,secondPoint,thirdPoint,fourthPoint)
        
        if(firstPoint==undefined || secondPoint==undefined || thirdPoint==undefined || fourthPoint==undefined) return false;     
                
        var angle1 = lineAngle(firstPoint, secondPoint, true);
        var angle2 = lineAngle(thirdPoint, fourthPoint, true);
        
        var rotationPoint1 = rotateAroundPoint(firstPoint, angle1+angleAddition, width);
        var rotationPoint2 = rotateAroundPoint(secondPoint, angle1+angleAddition, width);
        var rotationPoint3 = rotateAroundPoint(thirdPoint, angle2+angleAddition, width);
        var rotationPoint4 = rotateAroundPoint(fourthPoint, angle2+angleAddition, width);
        
        var intersectPoint = lineIntersect(rotationPoint1, rotationPoint2, rotationPoint3, rotationPoint4, false);        
        
        //console.log(intersectPoint)
        
        //createCircle("x", intersectPoint, 2, "#ff00ff", "#ff00ff", 0, layer1);
        //id, pos, r, stroke, fill, strokeWidth    
        //createPath([rotationPoint1,rotationPoint2], "none", "#333", 1, "cropMask", layerCrop);
        //createPath([rotationPoint3,rotationPoint4], "none", "#f1f1f1", 1, "cropMask", layerCrop);       
        
        //draw first point if open !closed
        if(i==0 & !closed){
            console.log("is false")
            pointListNew.push(rotationPoint1);
            //createCircle("x", rotationPoint1, 1, "#000", "#ff00ff", 0, layer1);            
        }
        var drawLast = (i==pointListLen-2 & !closed)? true:false;     
    
        //Draw internal points        
        if(intersectPoint!=false & !drawLast){    
            pointListNew.push(intersectPoint);
            //createCircle("x", intersectPoint, 1, "#000", "#ff00ff", 0, layer1);
        } 
    
        //draw last point if open
        if(drawLast){  
            var angle3 = lineAngle(pointList[pointListLen-2],pointList[pointListLen-1], true);
            var rotationPoint5 = rotateAroundPoint(pointList[pointListLen-1], angle3+angleAddition, width);
            //createCircle("x", rotationPoint5, 1, "#123456", "none", 0, layer1);
            pointListNew.push(rotationPoint5);      
        }
    }    
    return pointListNew;
    
    
}






populateLSysMenu();
changeTurnAngle(0, false);
changeIterations(0, false);
changeLineLength(0, false)
changeFromMenu(true);


//259.9
//156.7
//94.7
/*
console.log(94.7/259.9);
console.log(94.7/156.7);
var r = "0.6"
console.log((259.9 * Math.pow(r, 0)),  Math.pow(r, 0));
console.log((259.9 * Math.pow(r, 1)),  Math.pow(r, 1));
console.log((259.9 * Math.pow(r, 2)),  Math.pow(r, 2));
console.log((259.9 * Math.pow(r, 3)),  Math.pow(r, 2));
*/


</script>

<script>
//save image
function triggerDownload(imgURI) {
  const a = document.createElement('a');
  a.download = 'line_volume_svg.png'; // filename
  a.target = '_blank';
  a.href = imgURI;
  // trigger download button
  // (set `bubbles` to false here.
  // or just `a.click()` if you don't care about bubbling)
  a.dispatchEvent(new MouseEvent('click', {
    view: window,
    bubbles: false,
    cancelable: true
  }));
}

//const btn = document.querySelector('button');
//btn.addEventListener('click', function () {
function savePng(){
  const svgNode = container;
  const svgString = (new XMLSerializer()).serializeToString(svgNode);
  const svgBlob = new Blob([svgString], {
    type: 'image/svg+xml;charset=utf-8'
  });

  const DOMURL = window.URL || window.webkitURL || window;
  const url = DOMURL.createObjectURL(svgBlob);

  const image = new Image();
  image.width = svgNode.width.baseVal.value;
  image.height = svgNode.height.baseVal.value;
  image.src = url;
  image.onload = function () {
    const canvas = document.getElementById('svgCanvas');
    canvas.width = image.width;
    canvas.height = image.height;

    const ctx = canvas.getContext('2d');
    ctx.drawImage(image, 0, 0);
    DOMURL.revokeObjectURL(url);

    const imgURI = canvas
      .toDataURL('image/png')
      .replace('image/png', 'image/octet-stream');
    triggerDownload(imgURI);
  };
}




//let btn = document.querySelector('button')
//let svg = document.querySelector('svg')

function triggerDownloadSvg(imgURI, fileName){
    let a = document.createElement('a')
    a.setAttribute('download', 'line_volume.svg')
    a.setAttribute('href', imgURI)
    a.setAttribute('target', '_blank')
    a.click()
}

function saveSvg(){
    let data = (new XMLSerializer()).serializeToString(container)
    let svgBlob = new Blob([data], {type: 'image/svg+xml;charset=utf-8'})
    let url = URL.createObjectURL(svgBlob)
    triggerDownloadSvg(url)
}

//let btn = document.querySelector('button')
//btn.addEventListener('click', save)


function joinPathsInLayer(layer){
    //var pathList = [];
    let pathString = "";
    const paths = layer.getElementsByTagName("path");
    for(var i=0; i<paths.length; i++){
        //pathList.push(paths[i].getAttribute("d"));
        pathString += paths[i].getAttribute("d") + " "
    }
    console.log(paths.length)
    return pathString.trim();    
}

function copySvgToClipboard(layer){
    const svgStr = joinPathsInLayer(layer);
    navigator.clipboard.writeText(svgStr);

}




</script>


</html>
