<!DOCTYPE html>
<html lang="en">
<head>
<title>L-System Fractal Generator</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="icon" sizes="any" href="data:image/svg+xml;charset=UTF-8,%3Csvg%20id%3D%22designSvg%22%20width%3D%2220%22%20height%3D%2220%22%20version%3D%221.1%22%20viewBox%3D%220%200%2020%2020%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%20%3Cpath%20d%3D%22m3.26%2015%200.962%201.67%200.962-1.67h1.92l0.962%201.67-0.962%201.67h1.92l0.962%201.67%200.962-1.67h1.92l-0.962-1.67%200.962-1.67h1.92l0.962%201.67%200.962-1.67h1.92l-0.962-1.67%200.962-1.67h-1.92l-0.962-1.67%200.962-1.67h1.92l-0.962-1.67%200.962-1.67h-1.92l-0.962-1.67-0.962%201.67h-1.92l-0.962-1.67%200.962-1.67h-1.92l-0.962-1.67-0.962%201.67h-1.92l0.962%201.67-0.962%201.67h-1.92l-0.962-1.67-0.962%201.67h-1.92l0.962%201.67-0.962%201.67h1.92l0.962%201.67-0.962%201.67h-1.92l0.962%201.67-0.962%201.67z%22%20fill%3D%22%232e3d4d%22%2F%3E%0A%3C%2Fsvg%3E">
<style>
*{box-sizing:border-box;}
body{font-family:sans-serif; font-size: 13px; padding:0px; margin:0px; background-color:#8ea3b1;}
button{ background: #72899d; border:none; color:white; text-decoration:none; display:inline-block; cursor:pointer; border-radius: 4px; height: 25px; overflow: hidden; margin: 0px 5px 0px 5px; vertical-align: middle; margin-right: 4px;}
button:hover{background: #7f94a6;}
select, input[type="number"]{ border:none; padding: 4px; border-radius: 4px;}
input[type="range"] {accent-color:#72899d;  margin-top:5px;}
input[type="number"] {padding: 4px; width:40px; border-radius: 4px; border:none; margin: 3px 0px 0px 5px;}
.main{margin-top: 50px;}
/* --- Modal --- */
.modal-backdrop {position: fixed;  top: 0;  left: 0;  width: 100vw;  height: 100vh;  background: #00000060;  display: none;  align-items: center;  justify-content: center;  z-index: 1000;}
.modal {  background: #f1f1f1;  padding: 1.5rem;  border-radius: 10px;  max-width: 510px;  width: 90%;  box-shadow: 0 10px 30px #00000030;  position: relative;  color: #111111;}
.modal h2 {  margin-top: 0;}
.modal .close {  position: absolute;  top: 10px;  right: 14px;  font-size: 1.5rem;  color: #898989;  cursor: pointer;}
.modal .close:hover {  color: #000000;}
.modal-heading { font-size: 1.2rem;}
.modal-content div{ margin: 0.6rem 0rem;}
.modal-content .modal-block{ margin: 1rem;}
.hidden{display: none}
@media print { 
  .top-panel{ display: none !important; }
}
/* --- Top Panel --- */

.top-panel {
  display: flex;
  position: fixed;
  left: 0;
  top: 0;
  width: 100%;
  background-color: #2e3d4d;
  z-index: 10;
  color: #f1f1f1;
  padding: 8px 12px;
  align-items: center;
  gap: 10px;
  flex-wrap: wrap;
}

.control {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  white-space: nowrap;
}

.top-panel .number-spinner-group{display:flex;}
.number-spinner-group div{flex:1}
.number-spinner-group .number-text{flex:0 0 30px;}
.color-swatch{border-radius: 50%; width: 20px; height:20px; background: #333333; margin-top:2px; cursor:pointer; border: 2px solid #ffffff22;}
.color-swatch:hover{opacity:0.9}
.color-picker {display:none;}
.label{ text-align:right}
.number-text{background-color: #f1f1f1; padding:5px 7px 5px 7px; color: #000; height: 25px; margin:0px;}
.minus-btn{border-radius:3px 0px 0px 3px; margin: 0px;}
.plus-btn{border-radius:0px 3px 3px 0px; margin-left: 0px;}

@media (max-width: 480px) {
  .top-panel {
    gap: 6px 8px;
  }
  .label {
    width: 75px;
  }
}

</style>
</head>

<body>
  <div id="topPanel" class="top-panel">
    <div class="control">   
      <div class="label">Iterations</div>
      <div class="number-spinner-group">
        <button class="minus-btn blue" onclick="changeIterations(-1, true)">-</button>
        <div class="number-text" id="iterationsText">0</div>    
        <button class="plus-btn blue" onclick="changeIterations(1, true)">+</button>
      </div>
    </div>
    <div class="control">    
      <div class="label">Line Length</div>
      <div class="number-spinner-group">
        <button class="minus-btn blue" onclick="changeLineLength(-1, true)">-</button>
        <div class="number-text" id="lineLengthText">0</div>
        <button class="plus-btn blue" onclick="changeLineLength(1, true)">+</button>
      </div>    
    </div>
    <div class="control">    
      <div class="label">Turn Angle</div>
      <div class="number-spinner-group">
        <button class="minus-btn blue" onclick="changeTurnAngle(-1, true)">-</button>
        <div class="number-text" id="turnAngleText">0</div>
        <button class="plus-btn blue" onclick="changeTurnAngle(1, true)">+</button>
      </div>
    </div>
    <div class="control">   
      <div class="label">Type</div>
      <select id="lsysMenu" onchange="changeFromMenu(true)"></select>    
    </div>
    <div class="control"> 
      <div class="label">Save As</div>
      <button onclick="openModal('modalSave')">Save</button>
    </div>  
    <div class="control"> 
      <div id="zoomText" class="label">Zoom 100%</div>
      <input id="zoomRange" type="range" min="10" max="200" value="100" class="range" oninput="changeZoomRange(this.value)" /> 
    </div>
    <div class="control">     
      <div class="label">Inner Line</div>
      <input type="number" onchange="changeOutlineInside(this.value)" value="0" step="1" >
    </div>
    <div class="control"> 
      <div class="label">Outer Line</div>
      <input type="number" onchange="changeOutlineOuter(this.value)" value="0" step="1" >
    </div>
    <div class="control"> 
      <div class="label">Line Width</div>
      <input type="number" onchange="changeLineWidth(this.value)" value="1" step="1" > 
    </div>
    <div class="control"> 
      <div class="label">Line</div>
      <input id="lineColorInput" type="color" class="color-picker" value="#000000" oninput="changeLineColor(this.value)" />
      <div id="lineColorSwatch" class="color-swatch" onclick="document.getElementById('lineColorInput').click()"></div>
    </div>
    <div class="control"> 
      <div class="label">Background</div>
      <input id="backgroundColorInput" type="color" class="color-picker" value="#ffffff" oninput="changeBackgroundColor(this.value)" />   
      <div id="backgroundColorSwatch" class="color-swatch background-color-swatch" onclick="document.getElementById('backgroundColorInput').click()"></div> 
    </div>
  </div>
<div id="main" class="main">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1080 1080" id="designSvg" height="1080" width="1080">
        <g id="layer0"><rect id="background" width="1080" height="1080" fill="#ffffff" /></g>
        <g id="layer1"></g>
    </svg>
    <style>svg { background-color: rgba(255, 255, 255, 1); }</style>
    <div><canvas id="svgCanvas"></canvas></div>
</div>

<div class="modal-backdrop" id="modalBackdrop">
  <div class="modal">
    <span class="close" onclick="closeModal()" id="closeModalButton">&times;</span>

    <div id="modalSave" class="modal-content">
      <h2>Save As</h2>
      <div>
        <div id="lastSavedText" class="dom-el"></div>
        <button onclick="savePng()">Save PNG</button>
        <button onclick="saveSvg()">Save SVG</button>  
        <button onclick="copySvgToClipboard(layer1)">Copy to Clipboard</button>      
      </div>
    </div>
    </div>
</div>
</body>

<script>
// --- Global Declarations ---
const svgns = "http://www.w3.org/2000/svg";
const container = document.getElementById('designSvg');
const layer1 = document.getElementById('layer1');
const lsysMenu = document.getElementById('lsysMenu');
const modal = document.getElementById('myModal');
const backgroundColorInput = document.getElementById('backgroundColorInput');
const lineColorSwatch = document.getElementById('lineColorSwatch');
const backgroundColorSwatch = document.getElementById('backgroundColorSwatch');

let center = {x:540, y:540};
let lineLength = 10;
let currentPosition = center;
let nextPosition = center;
let posList = [currentPosition];
let convertList = ["X", "Y"];
let iterations = 3;
let turnAngle = 90;
let scaleFactor = 0.6;
let lSys = {};
let branchAngle = 90;
let branchColours = ["#000", "#ff0000", "#00ff00", "#0000ff", "#34aa12", "#123456", "#345612","#000", "#ff0000", "#00ff00", "#0000ff", "#34aa12", "#123456", "#345612"];
let designMin = {};
let designMax = {};

const app = {
  penDown: true,
  branchList: [],
  branchIndex: 0,
  recursiveBranchDepthIndex: 0,
  outlineInnerDistance: 0,
  outlineOuterDistance: 0,
  lineColor: '#333333',
  backgroundColor: '#f1f1f1',
  lineWidth: 1,
}

// L-Systems written by Paul Bourke, Chris Wallace, Hasan Hosam
// F - Move forward by line length drawing a line
// + - Turn left by turning angle
// - - Turn right by turning angle
const lSystemData = [
  {
    title: "Square Sierpinski",
    axiomStr: "F+XF+F+XF",
    ruleSets: ["XF-F+F-XF+F+XF-F+F-X"],
    axiomLetters: ["X"],
    turningAngle: 90,
    convertList: ["X"],
    startAngle: 0,
    branching: false,
    tags: ["sierpinski", "space-filling", "classic"]
  },
  {
    title: "Kosh Showflake",
    axiomStr: "F ++F ++F",
    ruleSets: ["F -F ++F -F"],
    axiomLetters: ["F"],
    turningAngle: 60,
    convertList: [],
    startAngle: 0,
    branching: false,
    tags: ["koch", "classic", "curve"]
  },
  {
    title: "Hilbert Curve",
    axiomStr: "X",
    ruleSets: ["-YF+XFX+FY-", "+XF-YFY-FX+"],
    axiomLetters: ["X", "Y"],
    turningAngle: 90,
    convertList: [],
    startAngle: 0,
    branching: false,
    tags: ["hilbert", "space-filling", "classic"]
  },
  {
    title: "Crystal",
    axiomStr: "F +F +F +F",
    ruleSets: ["F F +F ++F +F"],
    axiomLetters: ["F"],
    turningAngle: 90,
    convertList: [],
    startAngle: 0,
    branching: false,
    tags: ["polygonal", "decorative", "classic"]
  },
  {
    title: "Sierpinski Arrowhead",
    axiomStr: "YF",
    ruleSets: ["YF+XF+Y", "XF-YF-X"],
    axiomLetters: ["X", "Y"],
    turningAngle: 60,
    convertList: ["X", "Y"],
    startAngle: 0,
    branching: false,
    tags: ["sierpinski", "curve", "classic"]
  },

  {
    title: "Sierpinski Arrowhead 2",
    axiomStr: "A",
    ruleSets: ["B-A-B", "A+B+A"],
    axiomLetters: ["A", "B"],
    turningAngle: 60,
    convertList: ["A", "B"],
    startAngle: 0,
    branching: false,
    tags: ["sierpinski", "curve", "variant"]
  },

  {
    title: "Sierpinski Triangle",
    axiomStr: "F-G-G",
    ruleSets: ["F-G+F+G-F", "GG"],
    axiomLetters: ["F", "G"],
    turningAngle: 120,
    convertList: ["F", "G"],
    startAngle: 0,
    branching: false,
    tags: ["sierpinski", "space-filling", "classic"]
  },
  {
    title: "Koch Curve",
    axiomStr: "F",
    ruleSets: ["F+F-F-F+F"],
    axiomLetters: ["F"],
    turningAngle: 90,
    convertList: [],
    startAngle: 0,
    branching: false,
    tags: ["koch", "curve", "classic"]
  },
  {
    title: "Quadratic Snowflake",
    axiomStr: "F",
    ruleSets: ["F-F+F+F-F"],
    axiomLetters: ["F"],
    turningAngle: 90,
    convertList: [],
    startAngle: 0,
    branching: false,
    tags: ["koch", "polygonal", "decorative"]
  },
  {
    title: "Rings",
    axiomStr: "F +F +F +F",
    ruleSets: ["F F +F +F +F +F +F -F"],
    axiomLetters: ["F"],
    turningAngle: 90,
    convertList: [],
    startAngle: 45,
    branching: false,
    tags: ["polygonal", "decorative"]
  },
  {
    title: "Dragons Curve",
    axiomStr: "FX",
    ruleSets: ["X+YF+", "-FX-Y"],
    axiomLetters: ["X", "Y"],
    turningAngle: 90,
    convertList: [],
    startAngle: 0,
    branching: false,
    tags: ["dragon", "curve", "classic"]
  },
  {
    title: "Quadratic Gosper",
    axiomStr: "-YF",
    ruleSets: [
      "XFX-YF-YF+FX+FX-YF-YFFX+YF+FXFXYF-FX+YF+FXFX+YF-FXYF-YF-FX+FX+YFYF-",
      "+FXFX-YF-YF+FX+FXYF+FX-YFYF-FX-YF+FXYFYF-FX-YFFX+FX+YF-YF-FX+FX+YFY"
    ],
    axiomLetters: ["X", "Y"],
    turningAngle: 90,
    convertList: [],
    startAngle: 0,
    branching: false,
    tags: ["gosper", "space-filling", "classic"]
  },
  {
    title: "Quadratic Koch Island",
    axiomStr: "F+F+F+F",
    ruleSets: ["F+F-F-FFF+F+F-F"],
    axiomLetters: ["F"],
    turningAngle: 90,
    convertList: [],
    startAngle: 0,
    branching: false,
    tags: ["koch", "polygonal", "classic"]
  },
  {
    title: "Quadratic Koch Island 2",
    axiomStr: "F+F+F+F",
    ruleSets: ["F-FF+FF+F+F-F-FF+F+F-F-FF-FF+F"],
    axiomLetters: ["F"],
    turningAngle: 90,
    convertList: [],
    startAngle: 0,
    branching: false,
    tags: ["koch", "polygonal", "variant"]
  },
  {
    title: "Quadratic Koch Hosam",
    axiomStr: "X+X+X+X+X+X+X+X",
    ruleSets: [
      "X+YF++YF-FX--FXFX-YF+X",
      "-FX+YFYF++YF+FX--FX-YF"
    ],
    axiomLetters: ["X", "Y"],
    turningAngle: 45,
    convertList: [],
    startAngle: 0,
    branching: false,
    tags: ["koch", "gosper", "experimental"]
  },
  {
    title: "Peano Curve",
    axiomStr: "X",
    ruleSets: [
      "XFYFX+F+YFXFY-F-XFYFX",
      "YFXFY-F-XFYFX+F+YFXFY"
    ],
    axiomLetters: ["X", "Y"],
    turningAngle: 90,
    convertList: [],
    startAngle: 90,
    branching: false,
    tags: ["peano", "space-filling", "classic"]
  },
  {
    title: "Pentaplexity",
    axiomStr: "F++F++F++F++F",
    ruleSets: ["F++F++F|F-F++F"],
    axiomLetters: ["F"],
    turningAngle: 36,
    convertList: [],
    startAngle: 0,
    branching: false,
    tags: ["polygonal", "decorative", "classic"]
  },
  {
    title: "Hexagonal Gosper",
    axiomStr: "XF",
    ruleSets: [
      "X+YF++YF-FX--FXFX-YF+",
      "-FX+YFYF++YF+FX--FX-Y"
    ],
    axiomLetters: ["X", "Y"],
    turningAngle: 60,
    convertList: [],
    startAngle: 0,
    branching: false,
    tags: ["gosper", "space-filling", "classic"]
  },
  {
    title: "Levy Curve",
    axiomStr: "F",
    ruleSets: ["-F++F-"],
    axiomLetters: ["F"],
    turningAngle: 45,
    convertList: [],
    startAngle: 0,
    branching: false,
    tags: ["curve", "classic"]
  }
];

function changeLineColor(color){
  app.lineColor = color;
  lineColorSwatch.style.background = color;
  changeFromMenu(true);
}

function changeBackgroundColor(color){
  app.backgroundColor = color;
  backgroundColorSwatch.style.background = color;
  changeFromMenu(true);
}

function changeOutlineInside(distance){
  app.outlineInnerDistance = distance;
  changeFromMenu(true);
}

function changeOutlineOuter(distance){
  app.outlineOuterDistance = distance;
  changeFromMenu(true);
}

function changeLineWidth(width){
  app.lineWidth = width;
  changeFromMenu(true);
}


function changeZoomRange(zoom){
  zoomText.textContent = `Zoom ${zoom}%`;
  const newSize = Math.floor((100/zoom)*1080);
  container.setAttribute("viewBox", "0 0 " + newSize + " " + newSize);
}

function rotateAroundPoint(centerOfRotation, degrees, length){
  let xRot = centerOfRotation.x + (Math.cos(Math.PI/180 * degrees)*length);
  let yRot = centerOfRotation.y + (Math.sin(Math.PI/180 * degrees)*length);
  return {x:xRot,y:yRot};
}

function createCircle(id, pos, r, stroke, fill, strokeWidth){
  let circle = document.createElementNS(svgns, 'circle');
  circle.setAttributeNS(null, 'id', id);
  circle.setAttributeNS(null, 'cx', pos.x);
    circle.setAttributeNS(null, 'cy', pos.y);
    circle.setAttributeNS(null, 'r', r);
  circle.setAttributeNS(null, 'style', 'fill:' + fill + '; stroke:' + stroke + ';  opacity:1; stroke-width:' + strokeWidth + ';' );
  layer1.appendChild(circle);
}

function createPath(posList, fill, stroke, strokeWidth, adjx, adjy){
    let path = document.createElementNS(svgns, 'path');
    let d = "M" + (posList[0].x + adjx) + " " + (posList[0].y + adjy);
    //d += "A 1300 1300 0 0 1 "+ posList[1].x + " " + posList[1].y;

    for(let i=1; i<posList.length; i++) {
            let pos = posList[i]
            let com = (pos.command=="M")? " M":" L";
      d += com + (pos.x + adjx) + " " + (pos.y + adjy);
    }
        path.setAttributeNS(null, 'd', d);
    path.setAttributeNS(null, 'style', 'fill:' + fill + '; stroke:' + stroke + ';  opacity:1; stroke-width:' + strokeWidth + ';');
        layer1.appendChild(path);
}

function lSystem(title, axiomStr, axiomLetters, ruleSets, turningAngle, convertList, startAngle, branching){
  this.title = title;
  this.axiomStr = axiomStr;
  this.axiomLetters = axiomLetters;
  this.ruleSets = ruleSets;
  this.turningAngle = turningAngle;
  this.convertList = convertList;
  this.startAngle = startAngle;
  this.branching = branching;
}

function changelSystem(title){
  if(title != lSys.title){ //change only if system is different
    iterations = 3;
    changeIterations(0, false)
    let index = lSystemData.findIndex(x => x.title === title);
    lSys = lSystemData[index];
    turnAngle = lSys.turningAngle;
    changeTurnAngle(0, false);
  }
}

function populateLSysMenu(){
  for(let i=0; i<lSystemData.length; i++){
    lsysMenu.innerHTML += '<option value="' + lSystemData[i].title + '">' + lSystemData[i].title + '</otion>';
  }
}

function changeFromMenu(update){
  if(update){
    layer1.innerHTML = "";
    currentPosition = {x:540, y:540};
    nextPosition = currentPosition;
    posList = [currentPosition];
    changelSystem(lsysMenu.value);
    create();
  }
}

function iterate(axiomStr, axiomLetters, ruleSetsruleSets){
  let iterationStr = axiomStr;
  for(let i=0; i<lSys.axiomLetters.length; i++){
      let ruleSet = lSys.ruleSets[i].toLowerCase();
      iterationStr = replaceGlobally(iterationStr, axiomLetters[i], ruleSet);
  }
  iterationStr = iterationStr.replace(/ +(?= )/g,'');
  return iterationStr.toUpperCase().trim();
}

function replaceGlobally(original, searchTxt, replaceTxt){
  const regex = new RegExp(searchTxt, 'g');
  return original.replace(regex, replaceTxt) ;
}

function getIterationList(){
  let iterationString = lSys.axiomStr;
  for(let i=0; i<iterations; i++){
      iterationString = iterate(iterationString,lSys.axiomLetters, lSys.ruleSets);
  }
  iterationString = iterationString.replace(/\s/g, ""); //remove whitespace
  return iterationString.split("");
}

function getAngle(str, angle){
  if(str=="F"){
      angle = angle;
  }else if(str=="-"){
      angle = angle + turnAngle;
  }else if(str=="+"){
      angle = angle - turnAngle;
  }else if(str=="|"){
      angle = angle + (turnAngle*5);
  }
  return angle;
}

function Branch(pos, angle){
    this.pos = pos;
    this.angle = angle;
    this.updatePos = function(pos){
        this.pos = pos;
    }
    this.updateAngle = function(angle){
        this.angle = angle;
    }
}

function getPosition(str){
    currentPosition = nextPosition;
    //convert X,Y to F
    for(let i=0; i<lSys.convertList.length; i++){
        str = str.replace(lSys.convertList[i], "F");
    }
    if(str.includes("[")){
        app.branchList[app.branchIndex] = new Branch(currentPosition, startAngle);
        //console.log("set: ", lSys.startAngle, currentPosition);
        app.branchIndex++;
        app.branchList[app.branchIndex] = new Branch(currentPosition, startAngle);
        startAngle = app.branchList[app.branchIndex].angle;
        currentPosition = app.branchList[app.branchIndex].pos;
    }else if (str.includes("]")){
        //reset to previous index settings
        app.branchIndex--;
        startAngle = app.branchList[app.branchIndex].angle;
        currentPosition = app.branchList[app.branchIndex].pos;
        nextPosition = currentPosition;
        //console.log("reset: ", lSys.startAngle, currentPosition);
    }else{
    startAngle = getAngle(str, startAngle);
        if(str.includes("F")){
            lineLen = (lSys.branching)? ((lineLength * Math.pow(scaleFactor, app.branchIndex))*20):lineLength
            //lineLen = (lSys.branching)? (lineLength * branchLength[app.branchIndex]):lineLength
            nextPosition = rotateAroundPoint(currentPosition, startAngle, lineLen);
            nextPosition.command = "S";
            if(lSys.branching){
                createPath([currentPosition,nextPosition], app.lineColor, branchColours[app.branchIndex], app.lineWidth, 0, 0);
            }
        }else{
            nextPosition = currentPosition;
            nextPosition.command = "S";
            if(str.includes("U")){
                app.penDown = false;
            }else if(str.includes("D")){
                app.penDown = true;
                nextPosition.command = "M";
            }
            //console.log(nextPosition)
        }
    }
}

function resetMinMax(){
    designMin = {x:1000, y:1000}
    designMax = {x:0, y:0}
}

function minMaxer(pos){
    if(pos.x<designMin.x){designMin.x = pos.x;}
    if(pos.y<designMin.y){designMin.y= pos.y;}
    if(pos.x>designMax.x){designMax.x = pos.x;}
    if(pos.y>designMax.y){designMax.y = pos.y;}
}

function transformPoint(pos){
    let pt = designSvg.createSVGPoint();
    pt.x = pos.x;
    pt.y = pos.y;
    return pt.matrixTransform(designSvg.getScreenCTM().inverse());
}

function drawFromList(iterationList){
  resetMinMax();
  startAngle = lSys.startAngle;
  app.branchList[0] = new Branch(currentPosition, lSys.startAngle);
  for(let i=0; i<iterationList.length; i++){
      let ruleLetter = iterationList[i];
      getPosition(ruleLetter);
      if((currentPosition != nextPosition) || (nextPosition.command == "M" & app.penDown)){ // & app.penDown
          minMaxer(nextPosition)
          posList.push(nextPosition);
      }

  }

  let adjustx =  designMin.x + ((designMax.x - designMin.x) * 0.5);
  let adjusty =  designMin.y + ((designMax.y - designMin.y) * 0.5);
  let adjx = center.x - adjustx;
  let adjy = center.y - adjusty;

  if(app.outlineInnerDistance!=0){
    outline = outlinePoints(posList, true, app.outlineInnerDistance, true);
    createPath(outline, "rgba(0,0,0,0.1)", app.lineColor, app.lineWidth, adjx, adjy);
  }
  
  //createCircle("x", {x:adjustx, y:adjusty}, 4, "#00ff00", "#00ff00", 0)
  if(!lSys.branching){
    document.getElementById("background").setAttribute("fill", app.backgroundColor);
    let print = false;
    if(print){
        createPath(posList, "rgba(0,0,0,0.0)", "#000", 4, adjx, adjy);
        createPath(posList, "rgba(0,0,0,0.0)", "#fff", 3, adjx, adjy);
    }else{
        createPath(posList, "rgba(0,0,0,0.1)", app.lineColor, app.lineWidth, adjx, adjy);
    }
  }
  
  if(app.outlineOuterDistance!=0){
    //createCircle("x", {x:600, y:600}, 4, "#00ff00", "#00ff00", 0)
    outline = outlinePoints(posList, false, app.outlineOuterDistance, true)
    createPath(outline, "rgba(0,0,0,0.1)", app.lineColor, app.lineWidth, adjx, adjy);
  }
}

function create(){
  let iterationList = getIterationList();
  drawFromList(iterationList);
}

function clamp(min, max, val, original){
  if((val+original<min) || (val+original>max)){
    val=0;
  }
  return val;
}

function changeIterations(val, update){
  val = clamp(0, 20, val ,iterations);
  iterations += val;
  document.getElementById("iterationsText").innerHTML = iterations;
  changeFromMenu(update);
}

function changeLineLength(val, update){
  val = clamp(1, 50, val ,lineLength);
  lineLength += val;
  document.getElementById("lineLengthText").innerHTML = lineLength;
  changeFromMenu(update);
}

function changeTurnAngle(val, update){
    val = clamp(0, 360, val ,turnAngle);
    turnAngle += val;
    document.getElementById("turnAngleText").innerHTML = turnAngle;
    changeFromMenu(update);
}

function getIndex(num, total){
    let index = num % total
    if(index<0){
       index = total + num;
    }
    return index;
}

function lineAngle(pos1, pos2, positiveOnly){
  let deltaX = pos2.x - pos1.x ;
  let deltaY = pos2.y - pos1.y;
  let rad = Math.atan2(deltaY, deltaX); // In radians
  let deg = rad * (180 / Math.PI); // In degrees
  if(positiveOnly){
        if(deg<0){
            deg+=360}
        ;
    }
    return Number(deg.toFixed(5));
}

//improved line intersect - includes is the intersection along the segments
function lineIntersect(pos1, pos2, pos3, pos4, alongSegment){
  // Check if none of the lines are of length 0
  if ((pos1.x === pos2.x && pos1.y === pos2.y) || (pos3.x === pos4.x && pos3.y === pos4.y)) {
    return false;
  }
  let denominator = ((pos4.y - pos3.y) * (pos2.x - pos1.x) - (pos4.x - pos3.x) * (pos2.y - pos1.y));
  // Lines are parallel
  if (denominator === 0) {
    return false;
  }
  let ua = ((pos4.x - pos3.x) * (pos1.y - pos3.y) - (pos4.y - pos3.y) * (pos1.x - pos3.x)) / denominator;
  let ub = ((pos2.x - pos1.x) * (pos1.y - pos3.y) - (pos2.y - pos1.y) * (pos1.x - pos3.x)) / denominator;

    //is the intersection along the segments
    if(alongSegment==true){
        //console.log("in:", alongSegment)
        if (ua < 0 || ua > 1 || ub < 0 || ub > 1) {
            return false;
        }
    }
  // Return a object with the x and y coordinates of the intersection
  let x = pos1.x + ua * (pos2.x - pos1.x);
  let y = pos1.y + ua * (pos2.y - pos1.y);
  return {x, y};
}

function outlinePoints(pointListSrc, outside, width, closed){
    const pointList = Object.create(pointListSrc);
    //remove last as the same as first
    if(closed) pointList.pop();

    //console.log(closed)
    const angleAddition = (outside)? 90:-90;
    const loopAddition = (closed)? 1:-1;
    const pointListNew = [];
    const pointListLen = pointList.length;

    for(let i=0; i<(pointListLen+loopAddition); i++){
    //for(let i=0; i<pointListLen; i++){
        let firstPoint = pointList[getIndex(i, pointListLen)];
        let secondPoint = pointList[getIndex(i+1, pointListLen)];
        let thirdPoint = pointList[getIndex(i+1, pointListLen)];
        let fourthPoint = pointList[getIndex(i+2, pointListLen)];

        if(firstPoint==undefined || secondPoint==undefined || thirdPoint==undefined || fourthPoint==undefined) return false;

        let angle1 = lineAngle(firstPoint, secondPoint, true);
        let angle2 = lineAngle(thirdPoint, fourthPoint, true);

        let rotationPoint1 = rotateAroundPoint(firstPoint, angle1+angleAddition, width);
        let rotationPoint2 = rotateAroundPoint(secondPoint, angle1+angleAddition, width);
        let rotationPoint3 = rotateAroundPoint(thirdPoint, angle2+angleAddition, width);
        let rotationPoint4 = rotateAroundPoint(fourthPoint, angle2+angleAddition, width);

        let intersectPoint = lineIntersect(rotationPoint1, rotationPoint2, rotationPoint3, rotationPoint4, false);

        //draw first point if open !closed
        if(i==0 & !closed){
            console.log("is false")
            pointListNew.push(rotationPoint1);
            //createCircle("x", rotationPoint1, 1, "#000", "#ff00ff", 0, layer1);
        }
        let drawLast = (i==pointListLen-2 & !closed)? true:false;

        //Draw internal points
        if(intersectPoint!=false & !drawLast){
            pointListNew.push(intersectPoint);
        }

        //draw last point if open
        if(drawLast){
            let angle3 = lineAngle(pointList[pointListLen-2],pointList[pointListLen-1], true);
            let rotationPoint5 = rotateAroundPoint(pointList[pointListLen-1], angle3+angleAddition, width);
            //createCircle("x", rotationPoint5, 1, "#123456", "none", 0, layer1);
            pointListNew.push(rotationPoint5);
        }
    }
    return pointListNew;
}

//save image
function triggerDownload(imgURI) {
  const a = document.createElement('a');
  a.download = 'l-system-fractal.png'; // filename
  a.target = '_blank';
  a.href = imgURI;
  // trigger download button
  // (set bubbles to false here.
  // or just a.click() if you dont care about bubbling)
  a.dispatchEvent(new MouseEvent('click', {
    view: window,
    bubbles: false,
    cancelable: true
  }));
}

function savePng(){
  const svgNode = container;
  const svgString = (new XMLSerializer()).serializeToString(svgNode);
  const svgBlob = new Blob([svgString], {
    type: 'image/svg+xml;charset=utf-8'
  });

  const DOMURL = window.URL || window.webkitURL || window;
  const url = DOMURL.createObjectURL(svgBlob);

  const image = new Image();
  image.width = svgNode.width.baseVal.value;
  image.height = svgNode.height.baseVal.value;
  image.src = url;
  image.onload = function () {
    const canvas = document.getElementById('svgCanvas');
    canvas.width = image.width;
    canvas.height = image.height;

    const ctx = canvas.getContext('2d');
    ctx.drawImage(image, 0, 0);
    DOMURL.revokeObjectURL(url);

    const imgURI = canvas
      .toDataURL('image/png')
      .replace('image/png', 'image/octet-stream');
      triggerDownload(imgURI);
  };
  closeModal();
}

function triggerDownloadSvg(imgURI, fileName){
    let a = document.createElement('a')
    a.setAttribute('download', 'l-system-fractal.svg')
    a.setAttribute('href', imgURI)
    a.setAttribute('target', '_blank')
    a.click()
}

function saveSvg(){
    let data = (new XMLSerializer()).serializeToString(container)
    let svgBlob = new Blob([data], {type: 'image/svg+xml;charset=utf-8'})
    let url = URL.createObjectURL(svgBlob)
    triggerDownloadSvg(url);
    closeModal();
}

function joinPathsInLayer(layer){
    let pathString = "";
    const paths = layer.getElementsByTagName("path");
    for(let i=0; i<paths.length; i++){
        pathString += paths[i].getAttribute("d") + " "
    }
    console.log(paths.length)
    return pathString.trim();
}

function copySvgToClipboard(layer){
    const svgStr = joinPathsInLayer(layer);
    navigator.clipboard.writeText(svgStr);
}

// -- Modal ---
function openModal(sectionDiv) {
  document.getElementById('modalBackdrop').style.display = 'flex';
  document.querySelectorAll('.modal-content').forEach(el => {
    el.classList.add('hidden');
  });
  document.getElementById(sectionDiv).classList.remove('hidden');
}

function closeModal() {
  document.getElementById('modalBackdrop').style.display = 'none';
}

function init(){
  populateLSysMenu();
  changeTurnAngle(0, false);
  changeIterations(0, false);
  changeLineLength(0, false)
  changeFromMenu(true);
}

init();

</script>
</html>
